# -*- coding: utf-8 -*-
# Generated by Django 1.10.3 on 2016-11-28 11:08
from __future__ import unicode_literals

from django.db import migrations


DROP_DECK_SUMMARY_STATS_TRIGGER = """
	DROP TRIGGER IF EXISTS maint_deck_summary_stats ON games_globalgameplayer;
"""

DROP_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE = """
	DROP TRIGGER IF EXISTS maint_head_to_head_archetype_stats_trigger ON games_gamereplay;
"""


CREATE_TABLE_TIME_DIMENSION = """
	CREATE TABLE IF NOT EXISTS time_dimension (
		epoch_seconds	integer PRIMARY KEY,
		minute			integer NOT NULL,
		hour			integer NOT NULL,
		day				integer NOT NULL,
		month 			integer NOT NULL,
		year 			integer NOT NULL,
		day_of_week		integer NOT NULL
	);
"""
DROP_TABLE_TIME_DIMENSION = """
	DROP TABLE time_dimension;
"""

CREATE_ENSURE_TIME_DIMENSION_CREATED_FUNCTION = """
	CREATE OR REPLACE FUNCTION ensure_time_dimension_created(es numeric)
	RETURNS void AS $$
	DECLARE
		ts timestamp;
	BEGIN
		IF EXISTS (SELECT 1 FROM time_dimension t WHERE t.epoch_seconds = es) THEN
			RETURN;
		END IF;

		ts = to_timestamp(es);

		INSERT INTO time_dimension (
			epoch_seconds,
			minute,
			hour,
			day,
			month,
			year,
			day_of_week
		)
		VALUES (
			es,
			EXTRACT('minute' FROM ts),
			EXTRACT('hour' FROM ts),
			EXTRACT('day' FROM ts),
			EXTRACT('month' FROM ts),
			EXTRACT('year' FROM ts),
			EXTRACT('isodow' FROM ts)
		) ON CONFLICT DO NOTHING;

		RETURN;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_ENSURE_TIME_DIMENSION_CREATED_FUNCTION = """
	DROP FUNCTION ensure_time_dimension_created(es numeric);
"""

CREATE_TABLE_DECK_SUMMARY_STATS = """
	CREATE TABLE deck_summary_stats (
		epoch_seconds	int8 NOT NULL REFERENCES time_dimension (epoch_seconds),
		region_id		int8 NOT NULL,
		deck_id 		int8 NOT NULL REFERENCES cards_deck (id),
		player_class 	int2 NOT NULL,
		game_type		int2 NOT NULL,
		rank 			int2 NOT NULL DEFAULT -1,
		matches 		int2 NOT NULL DEFAULT 0,
		wins 			int2 NOT NULL DEFAULT 0,
		PRIMARY KEY (epoch_seconds, region_id, deck_id, player_class, game_type, rank)
	);
"""

DROP_TABLE_DECK_SUMMARY_STATS = """
	DROP TABLE deck_summary_stats;
"""

CREATE_IS_ELIGIBLE_FOR_STATS_FUNCTION = """
	CREATE OR REPLACE FUNCTION is_eligable_for_stats(player games_globalgameplayer)
	RETURNS boolean AS $$
	DECLARE
		global_game games_globalgame%ROWTYPE;
	BEGIN
		IF player.deck_list_id IS NOT NULL
		AND player.hero_id IS NOT NULL THEN

			SELECT * INTO STRICT global_game
			FROM games_globalgame
			WHERE id = player.game_id;

			IF global_game.match_start IS NOT NULL
			AND global_game.game_type IS NOT NULL THEN
				RETURN true;
			END IF;

		END IF;

		RETURN false;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_IS_ELIGIBLE_FOR_STATS_FUNCTION = """
	DROP FUNCTION is_eligable_for_stats(player games_globalgameplayer);
"""

CREATE_TO_DECK_SUMMARY_STATS_ROW_FUNCTION = """
	CREATE OR REPLACE FUNCTION to_deck_summary_stats_row(player games_globalgameplayer)
	RETURNS deck_summary_stats AS $$
	DECLARE
		ret deck_summary_stats%ROWTYPE;
	BEGIN
		ret.region_id = 0;
		ret.deck_id = player.deck_list_id;
		ret.rank = CASE WHEN player.rank IS NOT NULL THEN player.rank ELSE -1 END;
		ret.matches = 1;

		IF (player.final_state = 4) THEN
			ret.wins = 1;
		ELSE
			ret.wins = 0;
		END IF;

		SELECT c.card_class INTO STRICT ret.player_class
		FROM card c WHERE c.card_id = player.hero_id;

		-- We use seconds from epoch as our PK, but aggregate to the hour
		-- This gives us better storage efficiency, but leaves the door open later
		-- If we want to start aggregating to smaller intervals, like 10s or 1s
		SELECT
			round(date_part('epoch', date_trunc('hour', gg.match_start))),
			gg.game_type
		INTO STRICT ret.epoch_seconds, ret.game_type
		FROM games_globalgame gg
		WHERE gg.id = player.game_id;

		RETURN ret;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_TO_DECK_SUMMARY_STATS_ROW_FUNCTION = """
	DROP FUNCTION to_deck_summary_stats_row(player games_globalgameplayer);
"""

CREATE_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION = """
	CREATE OR REPLACE FUNCTION apply_deck_summary_stats_delta(
		delta deck_summary_stats,
		inc_decr numeric
	) RETURNS void AS $$
	DECLARE
	BEGIN
		-- incr_decr must be 1 or -1 anything else is an error
		IF (inc_decr != 1) AND (inc_decr != -1) THEN
			RAISE EXCEPTION 'inc_decr must be either 1 or -1';
		END IF;

		UPDATE deck_summary_stats
		SET matches = matches + (inc_decr * delta.matches),
			wins = wins + (inc_decr * delta.wins)
		WHERE epoch_seconds = delta.epoch_seconds
			AND region_id = delta.region_id
			AND deck_id = delta.deck_id
			AND player_class = delta.player_class
			AND game_type = delta.game_type
			AND rank = delta.rank;

		IF FOUND THEN
			-- If we successfully added the value to an existing row
			-- Then the task is complete
			RETURN;
		END IF;

		-- If we get here than there was no record to update.
		-- Check if incr_decr is -1, if so exit
		-- We can't decrement stats that don't exist

		-- The only way we should be decr stats that don't exist is if we have an error.
		-- Or we are in the brief period where the trigger is live, but we have
		-- not backfilled yet.

		IF (inc_decr = -1) THEN
			RETURN;
		END IF;

		-- If we get here than we must create the summary stats record
		-- We need to ensure the time_dimension has been pre-created
		PERFORM ensure_time_dimension_created(delta.epoch_seconds);

		INSERT INTO deck_summary_stats (
			epoch_seconds,
			region_id,
			deck_id,
			player_class,
			game_type,
			rank,
			matches,
			wins
		)
		VALUES (
			delta.epoch_seconds,
			delta.region_id,
			delta.deck_id,
			delta.player_class,
			delta.game_type,
			delta.rank,
			delta.matches,
			delta.wins
		) ON CONFLICT DO NOTHING;

	END;
	$$ LANGUAGE plpgsql;
"""

DROP_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION = """
	DROP FUNCTION apply_deck_summary_stats_delta(delta deck_summary_stats,inc_decr numeric);
"""

CREATE_MAINT_DECK_SUMMARY_STATS_FUNCTION = """
	CREATE OR REPLACE FUNCTION maint_deck_summary_stats() RETURNS TRIGGER AS $$
	BEGIN
		IF (TG_OP = 'DELETE') THEN

			IF is_eligable_for_stats(OLD) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(OLD), -1);
			END IF;

		ELSIF (TG_OP = 'UPDATE') THEN

			-- First we reverse out the old key values
			IF is_eligable_for_stats(OLD) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(OLD), -1);
			END IF;

			-- Then we update based on the new key values
			IF is_eligable_for_stats(NEW) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(NEW), 1);
			END IF;

		ELSIF (TG_OP = 'INSERT') THEN

			IF is_eligable_for_stats(NEW) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(NEW), 1);
			END IF;

		END IF;

		RETURN NULL;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_MAINT_DECK_SUMMARY_STATS_FUNCTION = """
	DROP FUNCTION maint_deck_summary_stats();
"""

CREATE_DECK_SUMMARY_STATS_TRIGGER = """
	CREATE TRIGGER maint_deck_summary_stats
	AFTER INSERT OR UPDATE OR DELETE ON games_globalgameplayer
		FOR EACH ROW EXECUTE PROCEDURE maint_deck_summary_stats();
"""

DROP_DECK_SUMMARY_STATS_TRIGGER = """
	DROP TRIGGER IF EXISTS maint_deck_summary_stats ON games_globalgameplayer;
"""


CREATE_INDEX_ON_DECK_SUMMARY_STATS_DECK_ID = """
	CREATE INDEX IF NOT EXISTS deck_summary_stats_deck_idx
	ON deck_summary_stats (deck_id);
"""

DROP_INDEX_ON_DECK_SUMMARY_STATS_DECK_ID = """
	DROP INDEX deck_summary_stats_deck_idx;
"""

CREATE_PRETTY_DECK_LIST_STRING_FUNC = """
	CREATE OR REPLACE FUNCTION pretty_deck_list_string(int8)
	RETURNS text AS $$
	SELECT string_agg(c.name || ' x ' || ci.count, ', ' ORDER BY c.cost)
	FROM cards_include ci
	JOIN card c ON c.card_id = ci.card_id
	WHERE ci.deck_id = $1;
	$$ LANGUAGE SQL STABLE;
"""

DROP_PRETTY_DECK_LIST_STRING_FUNC = """
	DROP FUNCTION pretty_deck_list_string(int);
"""

CREATE_DECK_DIGEST_FUNC = """
	CREATE OR REPLACE FUNCTION deck_digest(text[]) RETURNS text AS $$
	SELECT md5(convert_to(string_agg(c.id, ',' ORDER BY c.id), 'UTF8'))
	FROM UNNEST($1) c(id);
	$$ LANGUAGE SQL STABLE;
"""

DROP_DECK_DIGEST_FUNC = """
	DROP FUNCTION deck_digest(text[]);
"""

CREATE_GET_OR_CREATE_DECK_FUNC = """
CREATE OR REPLACE FUNCTION get_or_create_deck(text[])
	RETURNS TABLE (deck_id int, deck_creation_ts timestamp, digest text, created boolean, deck_size int) AS $$
	DECLARE
		computed_digest text;
		generated_deck_id int;
		deck_size int;
		created boolean;
		deck_created_ts timestamp;
	BEGIN
		-- Compute the deck digest
		computed_digest = deck_digest($1);
		deck_size = array_length($1, 1);

		SELECT cd.id, cd.created INTO generated_deck_id, deck_created_ts
		FROM cards_deck cd WHERE cd.digest = computed_digest;

		-- First check whether this deck already exists
		IF FOUND THEN
			created = false;
			RETURN QUERY SELECT generated_deck_id, deck_created_ts, computed_digest, created, deck_size;
			RETURN;
		END IF;

		-- Since the deck does not exist, we must now create it.
		BEGIN
			deck_created_ts = CURRENT_TIMESTAMP;
			INSERT INTO cards_deck (digest, size, created)
			VALUES (computed_digest, deck_size, deck_created_ts)
			RETURNING id INTO generated_deck_id;

			INSERT INTO cards_include (deck_id, card_id, count)
			SELECT generated_deck_id AS deck_id, c.id AS card_id, count(*)
			FROM UNNEST($1) c(id)
			GROUP BY c.id;

			created = true;

		EXCEPTION WHEN unique_violation THEN
			-- If an exception is thrown because another thread inserted the deck
			-- Then just query for the deck ID and let the other thread
			-- Remain responsible for building the deck
			SELECT cd.id, cd.created INTO generated_deck_id, deck_created_ts
			FROM cards_deck cd WHERE cd.digest = computed_digest;

			created = false;
		END;

		RETURN QUERY SELECT generated_deck_id, deck_created_ts, computed_digest, created, deck_size;
		RETURN;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_GET_OR_CREATE_DECK_FUNC = """
	DROP FUNCTION get_or_create_deck(text[]);
"""


CREATE_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS = """
CREATE TABLE IF NOT EXISTS head_to_head_archetype_stats (
	epoch_seconds int8 NOT NULL REFERENCES time_dimension (epoch_seconds),
	region_id int8 NOT NULL,
	game_type int2 NOT NULL,
	rank int2 NOT NULL DEFAULT -1,
	friendly_player_archetype_id int8 NOT NULL REFERENCES cards_archetype (id),
	opposing_player_archetype_id int8 NOT NULL REFERENCES cards_archetype (id),
	matches int2 NOT NULL DEFAULT 0,
	friendly_player_wins int2 NOT NULL DEFAULT 0,
	PRIMARY KEY (epoch_seconds, region_id, game_type, rank, friendly_player_archetype_id, opposing_player_archetype_id)
);
"""

DROP_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS = """
DROP TABLE head_to_head_archetype_stats;
"""

CREATE_FUNC_ELIGIBLE_FOR_ARCHETYPE_STATS = """
CREATE OR REPLACE FUNCTION is_eligable_for_archetype_stats(replay games_gamereplay)
RETURNS boolean AS $$
DECLARE
	user_record accounts_user%ROWTYPE;
	global_game games_globalgame%ROWTYPE;
	player_1 games_globalgameplayer%ROWTYPE;
	player_1_deck cards_deck%ROWTYPE;
	player_2 games_globalgameplayer%ROWTYPE;
	player_2_deck cards_deck%ROWTYPE;
BEGIN

	SELECT * INTO user_record
	FROM accounts_user
	WHERE id = replay.user_id;

	IF user_record IS NOT NULL AND user_record.exclude_from_statistics THEN
		return false;
	END IF;

	SELECT * INTO STRICT global_game
	FROM games_globalgame
	WHERE id = replay.global_game_id;

	IF global_game.game_type IS NOT NULL THEN

		SELECT * INTO player_1
		FROM games_globalgameplayer
		WHERE game_id = global_game.id AND player_id = 1;

		SELECT * INTO player_2
		FROM games_globalgameplayer
		WHERE game_id = global_game.id AND player_id = 2;

		-- Filter out draws to keep head_to_head stats symmetrical
		IF (
			(player_1.final_state = 4 AND player_2.final_state != 4)
			OR
			(player_1.final_state != 4 AND player_2.final_state = 4)
		)
		THEN

			SELECT * INTO player_1_deck
			FROM cards_deck
			WHERE id = player_1.deck_list_id;

			SELECT * INTO player_2_deck
			FROM cards_deck
			WHERE id = player_2.deck_list_id;

			IF player_1_deck.archetype_id IS NOT NULL
			AND player_2_deck.archetype_id IS NOT NULL
			THEN
				RETURN true;
			END IF;

		END IF;

	END IF;

	RETURN false;
END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_ELIGIBLE_FOR_ARCHETYPE_STATS = """
DROP FUNCTION is_eligable_for_archetype_stats(replay games_gamereplay)
"""

CREATE_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW = """
CREATE OR REPLACE FUNCTION to_head_to_head_archetype_stats_rows(replay games_gamereplay)
RETURNS SETOF head_to_head_archetype_stats AS $$
DECLARE
	global_game games_globalgame%ROWTYPE;
	stats_rank int4;
	player_1 games_globalgameplayer%ROWTYPE;
	player_1_deck cards_deck%ROWTYPE;
	player_2 games_globalgameplayer%ROWTYPE;
	player_2_deck cards_deck%ROWTYPE;
	player_1_perspective_result head_to_head_archetype_stats%ROWTYPE;
	player_2_perspective_result head_to_head_archetype_stats%ROWTYPE;
BEGIN

	SELECT * INTO STRICT global_game
	FROM games_globalgame
	WHERE id = replay.global_game_id;

	SELECT * INTO player_1
	FROM games_globalgameplayer
	WHERE game_id = global_game.id AND player_id = 1;

	SELECT * INTO player_2
	FROM games_globalgameplayer
	WHERE game_id = global_game.id AND player_id = 2;

	SELECT * INTO player_1_deck
	FROM cards_deck
	WHERE id = player_1.deck_list_id;

	SELECT * INTO player_2_deck
	FROM cards_deck
	WHERE id = player_2.deck_list_id;

	IF player_1.legend_rank IS NOT NULL OR player_2.legend_rank IS NOT NULL THEN
		stats_rank = 0;
	ELSIF player_1.rank IS NOT NULL OR player_2.rank IS NOT NULL THEN
		stats_rank = least(player_1.rank, player_2.rank);
	ELSE
		stats_rank = -1;
	END IF;


	-- First prepare the player_1_perspective_result
	-- If we roll up to the hour it will be ~500MM rows per year
	-- If we roll up to the day it will be ~22MM rows per year
	player_1_perspective_result.epoch_seconds = date_part('epoch', date_trunc('day', global_game.match_start));
	player_1_perspective_result.region_id = 0;
	player_1_perspective_result.game_type = global_game.game_type;
	player_1_perspective_result.rank = stats_rank;
	player_1_perspective_result.friendly_player_archetype_id = player_1_deck.archetype_id;
	player_1_perspective_result.opposing_player_archetype_id = player_2_deck.archetype_id;
	player_1_perspective_result.matches = 1;
	player_1_perspective_result.friendly_player_wins = CASE WHEN player_1.final_state = 4 THEN 1 ELSE 0 END;

	-- Then prepare the player_2_perspective_result;
	player_2_perspective_result.epoch_seconds = date_part('epoch', date_trunc('day', global_game.match_start));
	player_2_perspective_result.region_id = 0;
	player_2_perspective_result.game_type = global_game.game_type;
	player_2_perspective_result.rank = stats_rank;
	player_2_perspective_result.friendly_player_archetype_id = player_2_deck.archetype_id;
	player_2_perspective_result.opposing_player_archetype_id = player_1_deck.archetype_id;
	player_2_perspective_result.matches = 1;
	player_2_perspective_result.friendly_player_wins = CASE WHEN player_2.final_state = 4 THEN 1 ELSE 0 END;

	RETURN NEXT player_1_perspective_result;
	RETURN NEXT player_2_perspective_result;

	RETURN;

END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW = """
DROP FUNCTION to_head_to_head_archetype_stats_rows(replay games_gamereplay);
"""

CREATE_FUNC_APPLY_ARCHETYPE_STATS_DELTA = """
CREATE OR REPLACE FUNCTION apply_head_to_head_archetype_stats_delta(
	delta head_to_head_archetype_stats,
	inc_decr numeric
) RETURNS void AS $$
DECLARE
BEGIN
	-- incr_decr must be 1 or -1 anything else is an error
	IF (inc_decr != 1) AND (inc_decr != -1) THEN
		RAISE EXCEPTION 'inc_decr must be either 1 or -1';
	END IF;

	UPDATE head_to_head_archetype_stats
	SET matches = matches + (inc_decr * delta.matches),
		friendly_player_wins = friendly_player_wins + (inc_decr * delta.friendly_player_wins)
	WHERE epoch_seconds = delta.epoch_seconds
		AND region_id = delta.region_id
		AND game_type = delta.game_type
		AND rank = delta.rank
		AND friendly_player_archetype_id = delta.friendly_player_archetype_id
		AND opposing_player_archetype_id = delta.opposing_player_archetype_id;

	IF FOUND THEN
		-- If we successfully added the value to an existing row
		-- Then the task is complete
		RETURN;
	END IF;

	-- If we get here than there was no record to update.
	-- Check if incr_decr is -1, if so exit
	-- We can't decrement stats that don't exist

	-- The only way we should be decr stats that don't exist is if we have an error.
	-- Or we are in the brief period where the trigger is live, but we have
	-- not backfilled yet.

	IF (inc_decr = -1) THEN
		RETURN;
	END IF;

	-- If we get here than we must create the stats record
	-- We also need to ensure the time_dimension has been pre-created
	PERFORM ensure_time_dimension_created(delta.epoch_seconds);

	INSERT INTO head_to_head_archetype_stats (
		epoch_seconds,
		region_id,
		game_type,
		rank,
		friendly_player_archetype_id,
		opposing_player_archetype_id,
		matches,
		friendly_player_wins
	)
	VALUES (
		delta.epoch_seconds,
		delta.region_id,
		delta.game_type,
		delta.rank,
		delta.friendly_player_archetype_id,
		delta.opposing_player_archetype_id,
		delta.matches,
		delta.friendly_player_wins
	) ON CONFLICT DO NOTHING;

END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_APPLY_ARCHETYPE_STATS_DELTA = """
DROP FUNCTION apply_head_to_head_archetype_stats_delta(
	delta head_to_head_archetype_stats,
	inc_decr numeric
);
"""

CREATE_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS = """
CREATE OR REPLACE FUNCTION maint_head_to_head_archetype_stats() RETURNS TRIGGER AS $$
DECLARE
	rec head_to_head_archetype_stats%ROWTYPE;
BEGIN
	-- This trigger is attached to the games_gamereplay table.
	IF (TG_OP = 'DELETE') THEN

		IF is_eligable_for_archetype_stats(OLD) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(OLD) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, -1);
			END LOOP;
		END IF;

	ELSIF (TG_OP = 'UPDATE') THEN

		-- First we reverse out the old key values
		IF is_eligable_for_archetype_stats(OLD) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(OLD) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, -1);
			END LOOP;
		END IF;

		-- Then we update based on the new key values
		IF is_eligable_for_archetype_stats(NEW) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(NEW) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, 1);
			END LOOP;
		END IF;

	ELSIF (TG_OP = 'INSERT') THEN

		IF is_eligable_for_archetype_stats(NEW) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(NEW) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, 1);
			END LOOP;
		END IF;

	END IF;

	RETURN NULL;
END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS = """
DROP FUNCTION maint_head_to_head_archetype_stats();
"""

CREATE_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE = """
CREATE TRIGGER maint_head_to_head_archetype_stats_trigger
AFTER INSERT OR UPDATE OR DELETE ON games_gamereplay
	FOR EACH ROW EXECUTE PROCEDURE maint_head_to_head_archetype_stats();
"""

DROP_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE = """
DROP TRIGGER IF EXISTS maint_head_to_head_archetype_stats_trigger ON games_gamereplay;
"""


DROP_IDX_CARDS_DECK_DIGEST_914F4A6C = """
DROP INDEX cards_deck_digest_914f4a6c_like;
"""


DROP_IDX_CARDS_INCLUDE_DBE7A8F6 = """
DROP INDEX cards_include_card_id_dbe7a8f6_like;
"""


class Migration(migrations.Migration):

	dependencies = [
		('decks', '0001_initial'),
		('games', '0001_initial'),
	]

	operations = [
		migrations.RunSQL(
			CREATE_TABLE_TIME_DIMENSION,
			DROP_TABLE_TIME_DIMENSION
		),
		migrations.RunSQL(
			CREATE_ENSURE_TIME_DIMENSION_CREATED_FUNCTION,
			DROP_ENSURE_TIME_DIMENSION_CREATED_FUNCTION
		),
		migrations.RunSQL(
			CREATE_TABLE_DECK_SUMMARY_STATS,
			DROP_TABLE_DECK_SUMMARY_STATS
		),
		migrations.RunSQL(
			CREATE_IS_ELIGIBLE_FOR_STATS_FUNCTION,
			DROP_IS_ELIGIBLE_FOR_STATS_FUNCTION
		),
		migrations.RunSQL(
			CREATE_TO_DECK_SUMMARY_STATS_ROW_FUNCTION,
			DROP_TO_DECK_SUMMARY_STATS_ROW_FUNCTION
		),
		migrations.RunSQL(
			CREATE_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION,
			DROP_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION
		),
		migrations.RunSQL(
			CREATE_MAINT_DECK_SUMMARY_STATS_FUNCTION,
			DROP_MAINT_DECK_SUMMARY_STATS_FUNCTION
		),
		migrations.RunSQL(
			CREATE_DECK_SUMMARY_STATS_TRIGGER,
			DROP_DECK_SUMMARY_STATS_TRIGGER
		),
		migrations.RunSQL(
			CREATE_INDEX_ON_DECK_SUMMARY_STATS_DECK_ID,
			DROP_INDEX_ON_DECK_SUMMARY_STATS_DECK_ID
		),
		migrations.RunSQL(
			CREATE_PRETTY_DECK_LIST_STRING_FUNC,
			DROP_PRETTY_DECK_LIST_STRING_FUNC
		),
		migrations.RunSQL(
			CREATE_DECK_DIGEST_FUNC,
			DROP_DECK_DIGEST_FUNC
		),
		migrations.RunSQL(
			CREATE_GET_OR_CREATE_DECK_FUNC,
			DROP_GET_OR_CREATE_DECK_FUNC
		),
		migrations.RunSQL(
			CREATE_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS,
			DROP_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS
		),
		migrations.RunSQL(
			CREATE_FUNC_ELIGIBLE_FOR_ARCHETYPE_STATS,
			DROP_FUNC_ELIGIBLE_FOR_ARCHETYPE_STATS
		),
		migrations.RunSQL(
			CREATE_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW,
			DROP_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW
		),
		migrations.RunSQL(
			CREATE_FUNC_APPLY_ARCHETYPE_STATS_DELTA,
			DROP_FUNC_APPLY_ARCHETYPE_STATS_DELTA
		),
		migrations.RunSQL(
			CREATE_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS,
			DROP_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS
		),
		migrations.RunSQL(
			CREATE_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE,
			DROP_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE
		),
	]
