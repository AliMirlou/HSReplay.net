# -*- coding: utf-8 -*-
# Generated by Django 1.10.2 on 2016-11-01 21:08
from __future__ import unicode_literals

from django.db import migrations


CREATE_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS = """
CREATE TABLE IF NOT EXISTS head_to_head_archetype_stats (
	epoch_seconds int8 NOT NULL REFERENCES time_dimension (epoch_seconds),
	region_id int8 NOT NULL,
	game_type int2 NOT NULL,
	rank int2 NOT NULL DEFAULT -1,
	friendly_player_archetype_id int8 NOT NULL REFERENCES cards_archetype (id),
	opposing_player_archetype_id int8 NOT NULL REFERENCES cards_archetype (id),
	matches int2 NOT NULL DEFAULT 0,
	friendly_player_wins int2 NOT NULL DEFAULT 0,
	PRIMARY KEY (epoch_seconds, region_id, game_type, rank, friendly_player_archetype_id, opposing_player_archetype_id)
);
"""

DROP_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS = """
DROP TABLE head_to_head_archetype_stats;
"""

CREATE_FUNC_ELIGABLE_FOR_ARCHETYPE_STATS = """
CREATE OR REPLACE FUNCTION is_eligable_for_archetype_stats(replay games_gamereplay)
RETURNS boolean AS $$
DECLARE
	global_game games_globalgame%ROWTYPE;
	player_1 games_globalgameplayer%ROWTYPE;
	player_1_deck cards_deck%ROWTYPE;
	player_2 games_globalgameplayer%ROWTYPE;
	player_2_deck cards_deck%ROWTYPE;
BEGIN

	SELECT * INTO STRICT global_game
	FROM games_globalgame
	WHERE id = replay.global_game_id;

	IF global_game.game_type IS NOT NULL THEN

		SELECT * INTO player_1
		FROM games_globalgameplayer
		WHERE game_id = global_game.id AND player_id = 1;

		SELECT * INTO player_2
		FROM games_globalgameplayer
		WHERE game_id = global_game.id AND player_id = 2;

		IF player_1.deck_list_id IS NOT NULL AND player_1.account_hi IS NOT NULL
		AND player_2.deck_list_id IS NOT NULL AND player_2.account_hi IS NOT NULL
		-- Filter out draws to keep head_to_head stats symmetrical
		AND (
			(player_1.final_state = 4 AND player_2.final_state != 4)
			OR
			(player_1.final_state != 4 AND player_2.final_state = 4)
		)
		THEN

			SELECT * INTO player_1_deck
			FROM cards_deck
			WHERE id = player_1.deck_list_id;

			SELECT * INTO player_2_deck
			FROM cards_deck
			WHERE id = player_2.deck_list_id;

			IF player_1_deck.archetype_id IS NOT NULL
			AND player_2_deck.archetype_id IS NOT NULL
			THEN
				RETURN true;
			END IF;

		END IF;

	END IF;

	RETURN false;
END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_ELIGABLE_FOR_ARCHETYPE_STATS = """
DROP FUNCTION is_eligable_for_archetype_stats(replay games_gamereplay)
"""

CREATE_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW = """
CREATE OR REPLACE FUNCTION to_head_to_head_archetype_stats_rows(replay games_gamereplay)
RETURNS SETOF head_to_head_archetype_stats AS $$
DECLARE
	global_game games_globalgame%ROWTYPE;
	stats_rank int4;
	player_1 games_globalgameplayer%ROWTYPE;
	player_1_deck cards_deck%ROWTYPE;
	player_2 games_globalgameplayer%ROWTYPE;
	player_2_deck cards_deck%ROWTYPE;
	player_1_perspective_result head_to_head_archetype_stats%ROWTYPE;
	player_2_perspective_result head_to_head_archetype_stats%ROWTYPE;
BEGIN

	SELECT * INTO STRICT global_game
	FROM games_globalgame
	WHERE id = replay.global_game_id;

	SELECT * INTO player_1
	FROM games_globalgameplayer
	WHERE game_id = global_game.id AND player_id = 1;

	SELECT * INTO player_2
	FROM games_globalgameplayer
	WHERE game_id = global_game.id AND player_id = 2;

	SELECT * INTO player_1_deck
	FROM cards_deck
	WHERE id = player_1.deck_list_id;

	SELECT * INTO player_2_deck
	FROM cards_deck
	WHERE id = player_2.deck_list_id;

	IF player_1.legend_rank IS NOT NULL OR player_2.legend_rank IS NOT NULL THEN
		stats_rank = 0;
	ELSIF player_1.rank IS NOT NULL OR player_2.rank IS NOT NULL THEN
		stats_rank = least(player_1.rank, player_2.rank);
	ELSE
		stats_rank = -1;
	END IF;


	-- First prepare the player_1_perspective_result
	-- If we roll up to the hour it will be ~500MM rows per year
	-- If we roll up to the day it will be ~22MM rows per year
	player_1_perspective_result.epoch_seconds = date_part('epoch', date_trunc('day', global_game.match_start));
	player_1_perspective_result.region_id = player_1.account_hi;
	player_1_perspective_result.game_type = global_game.game_type;
	player_1_perspective_result.rank = stats_rank;
	player_1_perspective_result.friendly_player_archetype_id = player_1_deck.archetype_id;
	player_1_perspective_result.opposing_player_archetype_id = player_2_deck.archetype_id;
	player_1_perspective_result.matches = 1;
	player_1_perspective_result.friendly_player_wins = CASE WHEN player_1.final_state = 4 THEN 1 ELSE 0 END;

	-- Then prepare the player_2_perspective_result;
	player_2_perspective_result.epoch_seconds = date_part('epoch', date_trunc('day', global_game.match_start));
	player_2_perspective_result.region_id = player_2.account_hi;
	player_2_perspective_result.game_type = global_game.game_type;
	player_2_perspective_result.rank = stats_rank;
	player_2_perspective_result.friendly_player_archetype_id = player_2_deck.archetype_id;
	player_2_perspective_result.opposing_player_archetype_id = player_1_deck.archetype_id;
	player_2_perspective_result.matches = 1;
	player_2_perspective_result.friendly_player_wins = CASE WHEN player_2.final_state = 4 THEN 1 ELSE 0 END;

	RETURN NEXT player_1_perspective_result;
	RETURN NEXT player_2_perspective_result;

	RETURN;

END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW = """
DROP FUNCTION to_head_to_head_archetype_stats_rows(replay games_gamereplay);
"""

CREATE_FUNC_APPLY_ARCHETYPE_STATS_DELTA = """
CREATE OR REPLACE FUNCTION apply_head_to_head_archetype_stats_delta(
	delta head_to_head_archetype_stats,
	inc_decr numeric
) RETURNS void AS $$
DECLARE
BEGIN
	-- incr_decr must be 1 or -1 anything else is an error
	IF (inc_decr != 1) AND (inc_decr != -1) THEN
		RAISE EXCEPTION 'inc_decr must be either 1 or -1';
	END IF;

	UPDATE head_to_head_archetype_stats
	SET matches = matches + (inc_decr * delta.matches),
		friendly_player_wins = friendly_player_wins + (inc_decr * delta.friendly_player_wins)
	WHERE epoch_seconds = delta.epoch_seconds
		AND region_id = delta.region_id
		AND game_type = delta.game_type
		AND rank = delta.rank
		AND friendly_player_archetype_id = delta.friendly_player_archetype_id
		AND opposing_player_archetype_id = delta.opposing_player_archetype_id;

	IF FOUND THEN
		-- If we successfully added the value to an existing row
		-- Then the task is complete
		RETURN;
	END IF;

	-- If we get here than there was no record to update.
	-- Check if incr_decr is -1, if so exit
	-- We can't decrement stats that don't exist

	-- The only way we should be decr stats that don't exist is if we have an error.
	-- Or we are in the brief period where the trigger is live, but we have
	-- not backfilled yet.

	IF (inc_decr = -1) THEN
		RETURN;
	END IF;

	-- If we get here than we must create the stats record
	-- We also need to ensure the time_dimension has been pre-created
	PERFORM ensure_time_dimension_created(delta.epoch_seconds);

	INSERT INTO head_to_head_archetype_stats (
		epoch_seconds,
		region_id,
		game_type,
		rank,
		friendly_player_archetype_id,
		opposing_player_archetype_id,
		matches,
		friendly_player_wins
	)
	VALUES (
		delta.epoch_seconds,
		delta.region_id,
		delta.game_type,
		delta.rank,
		delta.friendly_player_archetype_id,
		delta.opposing_player_archetype_id,
		delta.matches,
		delta.friendly_player_wins
	) ON CONFLICT DO NOTHING;

END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_APPLY_ARCHETYPE_STATS_DELTA = """
DROP FUNCTION apply_head_to_head_archetype_stats_delta(
	delta head_to_head_archetype_stats,
	inc_decr numeric
);
"""

CREATE_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS = """
CREATE OR REPLACE FUNCTION maint_head_to_head_archetype_stats() RETURNS TRIGGER AS $$
DECLARE
	rec head_to_head_archetype_stats%ROWTYPE;
BEGIN
	-- This trigger is attached to the games_gamereplay table.
	IF (TG_OP = 'DELETE') THEN

		IF is_eligable_for_archetype_stats(OLD) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(OLD) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, -1);
			END LOOP;
		END IF;

	ELSIF (TG_OP = 'UPDATE') THEN

		-- First we reverse out the old key values
		IF is_eligable_for_archetype_stats(OLD) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(OLD) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, -1);
			END LOOP;
		END IF;

		-- Then we update based on the new key values
		IF is_eligable_for_archetype_stats(NEW) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(NEW) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, 1);
			END LOOP;
		END IF;

	ELSIF (TG_OP = 'INSERT') THEN

		IF is_eligable_for_archetype_stats(NEW) THEN
			FOR rec IN SELECT * FROM to_head_to_head_archetype_stats_rows(NEW) LOOP
				PERFORM apply_head_to_head_archetype_stats_delta(rec, 1);
			END LOOP;
		END IF;

	END IF;

	RETURN NULL;
END;
$$ LANGUAGE plpgsql;
"""

DROP_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS = """
DROP FUNCTION maint_head_to_head_archetype_stats();
"""

CREATE_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE = """
CREATE TRIGGER maint_head_to_head_archetype_stats_trigger
AFTER INSERT OR UPDATE OR DELETE ON games_gamereplay
	FOR EACH ROW EXECUTE PROCEDURE maint_head_to_head_archetype_stats();
"""

DROP_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE = """
DROP TRIGGER IF EXISTS maint_head_to_head_archetype_stats_trigger ON games_gamereplay;
"""


class Migration(migrations.Migration):

	dependencies = [
		('cards', '0005_auto_20161027_0244'),
	]

	operations = [
		migrations.RunSQL(
			CREATE_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS,
			DROP_TABLE_HEAD_TO_HEAD_ARCHETYPE_STATS
		),
		migrations.RunSQL(
			CREATE_FUNC_ELIGABLE_FOR_ARCHETYPE_STATS,
			DROP_FUNC_ELIGABLE_FOR_ARCHETYPE_STATS
		),
		migrations.RunSQL(
			CREATE_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW,
			DROP_FUNC_TO_HEAD_TO_HEAD_ARCHETYPE_STATS_ROW
		),
		migrations.RunSQL(
			CREATE_FUNC_APPLY_ARCHETYPE_STATS_DELTA,
			DROP_FUNC_APPLY_ARCHETYPE_STATS_DELTA
		),
		migrations.RunSQL(
			CREATE_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS,
			DROP_FUNC_MAINT_HEAD_TO_HEAD_ARCHETYPE_STATS
		),
		migrations.RunSQL(
			CREATE_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE,
			DROP_ARCHETYPE_STATS_TRIGGER_ON_GAMEREPLAY_TABLE
		),
	]
